// Global Variables
binarysem q_sem_1 = 1;
binarysem q_sem_2 = 0;
binarysem q_sem_3 = 0;

binarysem op_sem_1 = 0;
binarysem op_sem_2 = 0;

binarysem hm_sem_1 = 0;
binarysem hm_sem_2 = 0;
binarysem hm_sem_3 = 0;

binarysem sw_sem_1 = 0;
binarysem sw_sem_2 = 0;                      
binarysem sw_sem_dl = 0;                    // Once sw_sem_2 and dl are passed, act one ends
binarysem sw_sem_4 = 0;

binarysem sw_sem_l_4_open = 1;
binarysem sw_sem_5 = 0;
binarysem sw_sem_6 = 0;                     // Semaphore for SW to eat the poisned apple, and fall into a coma

// --- Dwarven Section --- //
int dwarf_counter = 0;                 // Tracks how many dwarves either left or returned, depends on where used
binarysem in_leave_cs = 1;

// Are we allowed to use bools, because if not
binarysem d_1_go_home = 0;
binarysem d_2_go_home = 0;
binarysem d_3_go_home = 0;

binarysem in_return_cs = 1;

binarysem d_sem_3 = 0;

binarysem d_sem_w_1 = 0;
binarysem d_sem_w_2 = 0;
binarysem d_sem_w_3 = 0;

binarysem in_d_w_cs = 1;                    // Semaphore for critical section in dwarf washing 

semaphore d_w_r_e = 0;                      // A dwarf washed but waiting for food made.                        

binarysem d_1_ate = 0;
binarysem d_2_ate = 0;
binarysem d_3_ate = 0;

int wash_order [3];

int i;                                      
int j = 0;
int k = 0;

// --------------- Functions --------------- //

atomic void queens_lines (int line_number) {
    cout << "Queen ";

    switch (line_number) {
        case 1:
            cout << "orders Huntsman take SW into forest and kill SW";
            break;
        case 2:
            cout << "relizes Huntsman tricked her, and decides to kill SW herself";
            break;
        case 3:
            cout << "disguises as Old Peddler";
            break;
    }

    cout << ".\n";
}
void queens_script () {
    wait(q_sem_1);                     // Allows only one to ever get past this point
    queens_lines(1);

    signal(hm_sem_1);           // The huntsman has recived his orders, thus he can carry them out
    
    wait (q_sem_2);
    queens_lines(2);
    queens_lines(3);

}

atomic void old_ped_lines (int line_number) {
    cout << "OP ";
    switch (line_number) {
        case 1:
            cout << "knocks on Dwarves house";
            break;
        case 2:
            cout << "offers SW poisoned apple";
            break;
    }
    cout << ".\n";
}

void old_ped_script () {
    wait(op_sem_1);
    old_ped_lines(1);
    signal(sw_sem_5);

    
    wait(op_sem_2);                         // Wait for Snow White to answer the door
    old_ped_lines(2);
    signal(sw_sem_6);                       // Signal allowing SW to eat the apple

}

atomic void huntsman_lines (int line_number) {
    cout << "Huntsman ";

    if (line_number == 1) {
    cout << "takes SW into forst";
    }
    else if (line_number == 2) {
    cout << "tells SW the Queens's plan, and let SW run away";
    }
    else {
        cout << "gives stag's heart to Queen";
    }

    cout << ".\n";
}
void huntsman_script () {
    wait(hm_sem_1);                   // Waits till the queen gives him orders
    huntsman_lines(1);
    signal(sw_sem_1);

    wait(hm_sem_2);
    huntsman_lines(2);
    signal(sw_sem_2);

    wait(hm_sem_3);
    huntsman_lines(3);
    signal(q_sem_2);
    
    // The huntsman job is finished.
}

atomic void sw_lines(int line_number) {
    cout << "SW ";

    switch (line_number) {
        case 1:
            cout << "follows Huntsman and entered forst";
            break;
        case 2:
            cout << "escapes, finds Dwarves' house, and falls asleep";
            break;
        case 3:
            cout << "expalins to dwarves what happened";
            break;
        case 5:
            cout << "listens to knocking sounds and opens door";
            break;
        case 6:
            cout << "eats poisoned apple";
            break;
        case 7:
            cout << "falls into coma";
            break;
    }

    cout << ".\n";
}

atomic void sw_line_4_msg (int dwarf_num) {
    cout << "SW prepares lunch for Dwarf " << dwarf_num << ".\n";
} 

void sw_line_4_func () {
    int dwarf_num;

    wait(sw_sem_l_4_open);
    dwarf_num = wash_order[j];
    sw_line_4_msg(dwarf_num);

    switch (dwarf_num) {
        case 1:
            signal(d_1_ate);
            break;
        case 2:
            signal(d_2_ate);
            break;
        case 3:
            signal(d_3_ate);
            break;
    }
    j++;
    signal(sw_sem_l_4_open);
}

void snow_white_script () {
    wait(sw_sem_1);
    sw_lines(1);
    signal(hm_sem_2);

    wait(sw_sem_2);                
    wait(sw_sem_dl);                        // I have to make sure that they all leave before this step occures 
    sw_lines(2);
    
    // Act 2 Begins
    signal(hm_sem_3);
    signal(d_1_go_home);
    signal(d_2_go_home);
    signal(d_3_go_home);
    
    wait(sw_sem_4);
    sw_lines(3);
    signal(d_sem_3);


    for (k = 1; k < 4; ++k) {
        wait(d_w_r_e);                         // Wait for a dwarf to finish washing
        sw_line_4_func();
    }

    // Once all the dwarves have left, let the Old Peddler arrive
    signal(op_sem_1);

    // The old peddler knocks on the door
    wait(sw_sem_5);
    sw_lines(5);
    signal(op_sem_2);

    wait(sw_sem_6);                         // SW is given the poisoned apple
    sw_lines(6);                            // Eats the poisned apple
    sw_lines(7);                            // <---------------------------- Could this cause an issue, I.e 7 before 6
    // Immediately, after eating apple, she falls into a coma
}

// ----- Dwarf Functions ----- //
atomic void print_dwarven_leave(int dwarf_num) {
    cout << "Dwarf " << dwarf_num << " goes to work in morning.\n";
}

void d_leave_func (int dwarf_num) {
    wait(in_leave_cs);
    
    print_dwarven_leave(dwarf_num);
    
    dwarf_counter++;

    if (dwarf_counter == 3) {
        dwarf_counter = 0;               // For use in when the dwarves return
        signal(sw_sem_dl);
    }

    signal(in_leave_cs);                    // Might be an issue
}

atomic void print_d_r_last(int dwarf_num) {
    cout << "Dwarf " << dwarf_num << " comes home, finds SW, and wakes SW up.\n";
}
                                            
atomic void print_d_r_NL(int dwarf_num) {  // // NL stands for not last
    cout << "Dwarf " << dwarf_num << " comes home, finds SW.\n";
}

void d_returns_func(int dwarf_num) {
    wait(in_return_cs);

    if (dwarf_counter == 2) {               // If 2, then that means that this will be the last dwarf to return
        print_d_r_last(dwarf_num);
        signal(sw_sem_4);
    }
    else {
        print_d_r_NL(dwarf_num);
        dwarf_counter++;
    }

    signal(in_return_cs);
}

atomic void d_wash_msg (int dwarf_num) {
    cout << "Dwarf " << dwarf_num << " washes for lunch.\n";
}

void dwarf_washing (int dwarf_num) {
    wait(in_d_w_cs);

    wash_order[i] = dwarf_num;
    d_wash_msg(dwarf_num);
    signal(d_w_r_e);                                        // WHy only once does it fire?
    i++;

    signal(in_d_w_cs);
}
atomic void dwarf_ate(int dwarf_num) {
    cout << "Dwarf " << dwarf_num << " eats lunch and foes to work.\n";
}

void dwarf_1_lr() {
    d_leave_func(1);
    
    wait(d_1_go_home);
    d_returns_func(1);

    wait(d_sem_w_1);
    dwarf_washing(1);

    wait(d_1_ate);
    dwarf_ate(1);
}
void dwarf_2_lr() {
    d_leave_func(2);
    
    wait(d_2_go_home);
    d_returns_func(2);

    wait(d_sem_w_2);
    dwarf_washing(2);

    wait(d_2_ate);
    dwarf_ate(2);
}
void dwarf_3_lr() {
    d_leave_func(3);

    wait(d_3_go_home);
    d_returns_func(3);

    wait(d_sem_w_3);
    dwarf_washing(3);

    wait(d_3_ate);
    dwarf_ate(3);
}

atomic void d_allow_stay (int dwarf_num) {
    cout << "Dwarf " << dwarf_num << " lets her stay as housemaid, with other dwarves.\n";
}

void dwarfs_shared() {
    wait(d_sem_3);

    for (i = 1; i < 4; ++i) {
        d_allow_stay(i);
    }

    signal(d_sem_3);

    if (i == 4) {
        i = 0;
        signal(d_sem_w_1);
        signal(d_sem_w_2);
        signal(d_sem_w_3);
    }
}



main () {
    string[72] intro_message;
    stringCopy(intro_message, "Once upon a time, there lived a lovely little princess named SW.\n");

    // Act 0: Intro
    cout << intro_message;

    cobegin {
        // Act 1: Learning of the queens intentions
        queens_script();
        old_ped_script();
        huntsman_script();
        snow_white_script();
        
        dwarf_1_lr();
        dwarf_2_lr();
        dwarf_3_lr();
        dwarfs_shared();
    }
}